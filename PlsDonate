local Scammed = 0
    local Players = game:GetService("Players")
    local debounce = Instance.new("Folder", game:GetService("CorePackages"))
    local httprequest = (syn and syn.request) or http and http.request or http_request or (fluxus and fluxus.request) or request
    local httpservice = game:GetService("HttpService")
    local Unclaimed = {}
    local ErrorCount = -1
    local queueonteleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
    queueonteleport("loadstring(game:HttpGet(''))()")
    if not getgenv().CasinoSettings then
        getgenv().CasinoSettings = {
            ['ServerHopDelay'] = 30,
            ['MinimumWithdrawAmount'] = 100,
            ['BegMessage'] = {
                ['Delay'] = 120,
                ['Messages'] = {
                    "üí∞ Want BOBUX? Come check out Casino Mania! üíµ",
                    "üíµ Are you BROKE? Come to Casino Mania to earn BOBUX! üí∏",
                    "üí∞ No DONATIONS? Come over to Casino Mania to earn some BOBUX! üí∏",
                    "üí∞ Feeling LUCKY? Come gamble w/ us at Casino Mania! üíµ",
                    "üí∏ Want to TEST your LUCK? Come head over to Casino Mania now! üí∞",
                    "üíµ TEST your LUCK TODAY! Check out Casino Mania, and you may earn some BOBUX! üí∞"
                }
            }
        }
    end
    local SignMessage = [[
üí∏  Earn BOBUX!!
ü§ò  Casino Mania, the best money maker!
        
üèì  Type ".help" to get started!
    ]]
    local CurrentPlayers = {}
    for _,v in next, Players:GetPlayers() do
        v:SetAttribute('Donated', 0)
    end
    Players.PlayerAdded:Connect(function(player)
        player:SetAttribute('Donated', 0)
    end)
    local function ServerHopServers()
        local gameId
        gameId = "8737602449"
        local Servers = {}
        local Request = httprequest({
            Url = "https://games.roblox.com/v1/games/"..gameId.."/servers/Public?sortOrder=Desc&limit=100"
        })
        local Body = httpservice:JSONDecode(Request.Body)
        if Body and Body.data then
            for i, v in next, Body.data do
                if type(v) == "table" and tonumber(v.playing) and tonumber(v.maxPlayers) and v.playing < v.maxPlayers and v.playing > 19 then
                    table.insert(Servers, 1, v.id)
                end
            end
        end
        if #Servers > 0 then
            game:GetService("TeleportService"):TeleportToPlaceInstance(gameId, Servers[math.random(1, #Servers)], Players.LocalPlayer)
        end
        game:GetService("TeleportService").TeleportInitFailed:Connect(function()
            task.wait(5)
            game:GetService("TeleportService"):TeleportToPlaceInstance(gameId, Servers[math.random(1, #Servers)], Players.LocalPlayer)
        end)
    end
    local function getRemote(name)
        return require(game:GetService("ReplicatedStorage").Remotes).Event(name)
    end
    getRemote('SetDonatedVisibility'):FireServer(false)
    local function chat(text)
        game:GetService('ReplicatedStorage').DefaultChatSystemChatEvents.SayMessageRequest:FireServer(text, 'All')
    end
    local function findUnclaimed()
        for i, v in pairs(Players.LocalPlayer.PlayerGui:WaitForChild'MapUIContainer':WaitForChild'MapUI'.BoothUI:GetChildren()) do
            if (v.Details.Owner.Text == "Unclaimed") then
                table.insert(Unclaimed, tonumber(string.match(tostring(v), "%d+")))
            end
        end
    end
    if not pcall(findUnclaimed) then
        ServerHopServers()
    end
    local function waitServerHop()
        task.wait(getgenv().CasinoSettings.ServerHopDelay * 60)
        ServerHopServers()
    end
    local function hopSet()
        if hopTimer then
            task.cancel(hopTimer)
        end
        hopTimer = task.spawn(waitServerHop)
    end
    local claimCount = #Unclaimed
    local function boothclaim()
        require(game:GetService('ReplicatedStorage').Remotes).Event("ClaimBooth"):InvokeServer(Unclaimed[1])
        if not string.find(Players.LocalPlayer.PlayerGui.MapUIContainer.MapUI.BoothUI:FindFirstChild(tostring("BoothUI" .. Unclaimed[1])).Details.Owner.Text, Players.LocalPlayer.DisplayName) then
            task.wait(1)
            if not string.find(Players.LocalPlayer.PlayerGui.MapUIContainer.MapUI.BoothUI:FindFirstChild(tostring("BoothUI" .. Unclaimed[1])).Details.Owner.Text, Players.LocalPlayer.DisplayName) then
                error()
            end
        end
    end
    --Checks if booth claim fails
    while not pcall(boothclaim) do
        if errCount >= claimCount then
            ServerHopServers()
        end
        table.remove(Unclaimed, 1)
        errCount = ErrorCount + 1
    end
    hopSet()
    local function walkToBooth()
        theCframe = CFrame.new(0, 0, 3)
        local boothPos, mainPosX
        for i, v in ipairs(game:GetService("Workspace").BoothInteractions:GetChildren()) do
            if v:GetAttribute("BoothSlot") == Unclaimed[1] then
                mainPosX = v.CFrame
                boothPos = v.CFrame * theCframe
                break
            end
        end
        game:GetService('VirtualInputManager'):SendKeyEvent(true, "LeftControl", false, game)
        local Controls = require(Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule")):GetControls()
        Controls:Disable()
        local atBooth = false
        pcall(function()
        game:GetService("Workspace").Map.Main.Bench:Destroy()
        end)
        Players.LocalPlayer.Character.Humanoid:MoveTo(boothPos.Position)
        Players.LocalPlayer.Character.Humanoid.MoveToFinished:Connect(function(reached)
            atBooth = true
        end)
        repeat
            task.wait()
        until atBooth
        Players.LocalPlayer.Character.Humanoid.RootPart.CFrame = CFrame.new(boothPos.Position)
        Controls:Enable()
        game:GetService('VirtualInputManager'):SendKeyEvent(false, "LeftControl", false, game)
        Players.LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(Players.LocalPlayer.Character.Humanoid.RootPart.Position, Vector3.new(40, 14, 101)))
    end
    walkToBooth()
    getRemote('SetBoothText'):FireServer(text, 'booth')
    local Raised = Players.LocalPlayer.leaderstates.Raised
    local oldValue = Raised.Value
    Raised:GetPropertyChangedSignal('Value'):Connect(function()
        local newVal = Raised.Value
        local RaisedN = newVal - oldValue
        task.wait(0.5)
        local LogService = game:GetService("LogService")
        local logs = LogService:GetLogHistory()
        if string.find(logs[#logs].message, Players.LocalPlayer.DisplayName) then
            local msg = string.gsub(logs[#logs].message, ' tipped ', ''):gsub('ÓÄÇ', ''):gsub('üí∏', ''):gsub(' to ', ''):gsub(Players.LocalPlayer.DisplayName, ''):gsub(tostring(Players.LocalPlayer.leaderstats.Raised.Value - RaisedC),
            for i, v in next, Players:GetPlayers() do
                if v.DisplayName == msg then
                    playerWhoDonated = v
                    chat('üí∏ ' .. RaisedN .. ' has been added to your balance! üí∏')
                    playerWhoDonated:SetAttribute('Donated', playerWhoDonated:GetAttribute('Donated') + RaisedN)
                end
            end
            if not playerWhoDonated then
               chat('üí∏ Could not fetch who donated me! Please stay close to me! üí∏')
               task.wait(6)
               local players = Players:GetPlayers()
                       local closestPlayer = nil
                       local closestDistance = math.huge
    
                       for i, player in ipairs(players) do
                         local distance = (player.Character.Head.Position - Players.LocalPlayer.Character.Head.Position).Magnitude
                         if distance < closestDistance and player ~= Players.LocalPlayer then
                           playerWhoDonated = player
                           closestDistance = distance
                         end
                       end
            playerWhoDonated:SetAttribute('Donated',RaisedN)
            chat('üí∏ Added ' .. RaisedN .. ' to ' .. playerWhoDonated.Name .. ' üí∏')
            end
            else
               chat('üí∏ Could not fetch who donated me! Please stay close to me! üí∏')
               task.wait(6)
               local players = Players:GetPlayers()
                       local closestPlayer = nil
                       local closestDistance = math.huge
    
                       for i, player in ipairs(players) do
                         local distance = (player.Character.Head.Position - Players.LocalPlayer.Character.Head.Position).Magnitude
                         if distance < closestDistance and player ~= Players.LocalPlayer then
                           playerWhoDonated = player
                           closestDistance = distance
                         end
                       end
            playerWhoDonated:SetAttribute('Donated',RaisedN)
            chat('üí∏ Added ' .. RaisedN .. ' to ' .. playerWhoDonated.Name .. ' üí∏')
        end
        oldValue = Raised.Value
        hopSet()
    end)
    local Prefix = "."
    MessageDone = game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.OnMessageDoneFiltering
    MessageDone.OnClientEvent:Connect(function(msgdata)
        local Speaker = tostring(msgdata.FromSpeaker)
        local Message = string.lower(msgdata.Message)
        local plrChatted = game:GetService("Players")[Speaker] or nil
        if (plrChatted and plrChatted == game:GetService('Players').LocalPlayer) or not plrChatted or debounceThing:FindFirstChild(plrChatted.Name) or string.find(message,'üí∏') or string.find(message,'üíé') then
            return
        end
        local Balls = plrChatted:GetAttribute("Donated")
        if Message == 'scam' then
            Scammed = Scammed +1
            if Scammed > 4 then
                ServerHopServers()
            end
        end
        if Message == Prefix..'balance' or Message == Prefix..'bal' then
            chat('üí∞ Your current balance: '..tostring(Balls) or '0'..' Bobux')
            return
        end
        if Message == Prefix..'play' then
            chat('üí∏ Specify a specific amount of Bobux to gamble for! (.play [amt])')
            return
        end
        if string.match(Message, '.play ') then
            local slotValx = string.gsub(Message, '.play ', '')
            if not tonumber(slotValx) or tonumber(slotValx) < 0 then
                chat('üí∏ Enter a valid amount! | .play [amt]')
                return
            end
            local slotVal = tonumber(slotValx)
            if Balls == 0 then
                chat('üí∏ Your balance is 0! You cannot play!')
                return
            end
            if Balls < slotVal then
                chat('üí∏ Your balance is lower than the value you provided!')
                return
            end
            local num
            local num = math.random() * 2 - 1
            local oldBalance = plrChatted:GetAttribute('Donated')
            local newBalance = math.floor(num * slotValx + oldBalance)
                   if newBalance < 0 then
                      newBalance = 0
                    end
            if newBalance > oldBalance then
                chat('üí∏ You won! Your new balance is: '..newBalance)
            elseif newBalance < oldBalance then
                chat('üí∏ You lost! Your new balance is: '..newBalance)
            else
                chat('üí∏ Your balance stays the same.. :(')
            end
            plrChatted:SetAttribute('Donated', newBalance)		
        end
        if Message == Prefix..'help' then
            chat('Help Page | .withdraw [amt] | .play [amt] | .bal / .balance || Amount of Bobux you donate, will be sent to your Balance.')
        end
        if Message == Prefix..'withdraw' then
            if plrChatted:GetAttribute('Donated') < getgenv().CasinoSettings.MinimumWithdrawAmount then
                chat('üí∏ You need to get atleast ' .. getgenv().CasinoSettings.MinimumWithdrawAmount .. ' to withdraw!')
                return
            end
            ServerHopServers()
        end
    end)
    task.spawn(function()
        while task.wait(getgenv().CasinoSettings.Beg.Delay) do
            chat(getgenv().CasinoSettings.Beg.BegMessage[math.random(1, #getgenv().CasinoSettings.Beg.BegMessage)])
        end
    end)
    chat(getgenv().CasinoSettings.Beg.BegMessage[math.random(1, #getgenv().CasinoSettings.Beg.BegMessage)])
    local boothText = require(game.ReplicatedStorage.Remotes).Event("SetBoothText")
    task.spawn(function()
        while true do
            task.wait(1)
            boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[Casino-Mania--------]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
            boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[-Casino-Mania-------]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
            boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[--Casino-Mania------]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
            boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[---Casino-Mania-----]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
            boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[----Casino-Mania----]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
            boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[-----Casino-Mania---]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
            boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[------Casino-Mania--]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
            boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[-------Casino-Mania-]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
            boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[--------Casino-Mania]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[-------Casino-Mania-]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[------Casino-Mania--]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[-----Casino-Mania---]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[----Casino-Mania----]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[---Casino-Mania-----]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!
[--Casino-Mania------]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
boothText:FireServer([[üí∏  Earn BOBUX!!  üí∏
ü§ò Casino mania, the best money maker!

[-Casino-Mania------]

üèì  Type ".help" to get started!  ü§ô]], "booth")
            task.wait(1)
        end
    end)
    if setfpscap then setfpscap(0) end
    if hookmetamethod then
        local old
        old = hookmetamethod(game,"__namecall",function(self,...)
            local args = {...}
            local method = getnamecallmethod()
            if tostring(self) == "SayMessageRequest" and method == "FireServer" then
                args[1] = args[1]:gsub('üíé','üí∏')
                return old(self,unpack(args))
            end
            return old(self,...)
        end)
    end
    while task.wait(getgenv().settin.ServerHopDelay * 60) do
        if not hopTimer then
            hopSet()
        end
    end
